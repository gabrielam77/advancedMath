<!DOCTYPE html>
<html lang="he">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>××•×¨×” ×§×•×œ×™ ×œ××ª××˜×™×§×”</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            color: #333;
            padding: 15px;
            position: relative;
            overflow: hidden;
            gap: 15px;
        }

        body::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                radial-gradient(circle at 20% 50%, rgba(255, 255, 255, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 80% 80%, rgba(255, 255, 255, 0.1) 0%, transparent 50%);
            pointer-events: none;
        }

        .sidebar {
            background: rgba(255, 255, 255, 0.98);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            box-shadow: 
                0 20px 40px rgba(0,0,0,0.15),
                0 0 0 1px rgba(255,255,255,0.5) inset;
            padding: 20px 15px;
            width: 180px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            animation: fadeInLeft 0.6s ease-out;
            align-items: center;
        }

        @keyframes fadeInLeft {
            from {
                opacity: 0;
                transform: translateX(-30px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        .logo-container {
            margin-bottom: 10px;
        }

        .logo {
            width: 120px;
            height: auto;
            filter: drop-shadow(0 8px 20px rgba(0,0,0,0.2));
        }

        .sidebar-divider {
            width: 100%;
            height: 2px;
            background: linear-gradient(90deg, transparent, #e2e8f0, transparent);
            margin: 5px 0;
        }

        .main-content {
            display: flex;
            gap: 15px;
            flex: 1;
            overflow: hidden;
            align-items: flex-start;
        }

        .container {
            background: rgba(255, 255, 255, 0.98);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            box-shadow: 
                0 20px 40px rgba(0,0,0,0.15),
                0 0 0 1px rgba(255,255,255,0.5) inset;
            padding: 25px 30px;
            flex: 1;
            text-align: center;
            position: relative;
            animation: fadeInUp 0.6s ease-out;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .history-card {
            background: rgba(255, 255, 255, 0.98);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            box-shadow: 
                0 20px 40px rgba(0,0,0,0.15),
                0 0 0 1px rgba(255,255,255,0.5) inset;
            padding: 25px 20px;
            width: 320px;
            animation: fadeInUp 0.6s ease-out 0.2s both;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            flex-shrink: 0;
            position: sticky;
            top: 20px;
            max-height: calc(100vh - 80px);
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        h1 {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 15px;
            font-size: 1.6em;
            font-weight: 800;
            letter-spacing: -0.5px;
            animation: slideDown 0.6s ease-out 0.2s both;
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .status {
            font-size: 0.9em;
            margin: 15px 0;
            padding: 12px 20px;
            border-radius: 15px;
            font-weight: 600;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 4px 15px rgba(0,0,0,0.08);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }

        .status.listening {
            background: linear-gradient(135deg, #e6fffa 0%, #b2f5ea 100%);
            color: #234e52;
            border: 2px solid #38b2ac;
            animation: statusPulse 2s ease-in-out infinite;
        }

        .status.speaking {
            background: linear-gradient(135deg, #fef5e7 0%, #feebc8 100%);
            color: #744210;
            border: 2px solid #f6ad55;
            animation: statusPulse 2s ease-in-out infinite;
        }

        .status.waiting {
            background: linear-gradient(135deg, #f0fff4 0%, #c6f6d5 100%);
            color: #22543d;
            border: 2px solid #68d391;
        }

        .compatibility-notice {
            margin: 10px 0 0;
            padding: 12px 18px;
            border-radius: 14px;
            background: linear-gradient(135deg, #fff5f5 0%, #fed7d7 100%);
            color: #742a2a;
            border: 2px solid #f56565;
            font-size: 0.85em;
            line-height: 1.5;
            text-align: right;
            box-shadow: 0 10px 30px rgba(245, 101, 101, 0.15);
        }

        .manual-answer {
            margin: 20px 0 10px;
            padding: 18px 20px;
            border-radius: 16px;
            background: linear-gradient(135deg, #f7fafc 0%, #edf2f7 100%);
            box-shadow: 0 8px 24px rgba(15, 23, 42, 0.08);
            display: flex;
            flex-direction: column;
            gap: 12px;
            align-items: stretch;
        }

        .manual-answer label {
            font-weight: 700;
            color: #2d3748;
            font-size: 0.9em;
            text-align: right;
        }

        .manual-input-row {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .manual-input-row input {
            flex: 1;
            padding: 12px 16px;
            border-radius: 12px;
            border: 2px solid #cbd5f5;
            font-size: 1em;
            transition: border-color 0.3s ease, box-shadow 0.3s ease;
            text-align: right;
        }

        .manual-input-row input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.2);
        }

        .manual-input-row input:disabled {
            background: #f1f5f9;
            cursor: not-allowed;
            border-color: #e2e8f0;
        }

        .manual-input-row button {
            width: auto;
            min-width: 140px;
            padding: 12px 20px;
        }

        .manual-input-row button:disabled {
            cursor: not-allowed;
        }

        .manual-hint {
            font-size: 0.8em;
            color: #4a5568;
            text-align: right;
            line-height: 1.5;
        }

        @keyframes statusPulse {
            0%, 100% {
                box-shadow: 0 4px 15px rgba(0,0,0,0.08);
            }
            50% {
                box-shadow: 0 6px 25px rgba(0,0,0,0.15);
            }
        }

        .question-display {
            font-size: 2.5em;
            margin: 15px 0;
            color: #2d3748;
            font-weight: 800;
            min-height: 80px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: linear-gradient(135deg, #f7fafc 0%, #edf2f7 100%);
            border-radius: 20px;
            padding: 20px;
            box-shadow: 
                0 10px 30px rgba(0,0,0,0.06),
                0 0 0 1px rgba(0,0,0,0.03) inset;
            transition: all 0.4s ease;
            letter-spacing: 0.05em;
        }

        .question-display:not(:empty) {
            animation: questionAppear 0.5s cubic-bezier(0.4, 0, 0.2, 1);
        }

        @keyframes questionAppear {
            from {
                opacity: 0;
                transform: scale(0.9);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        .progress {
            margin: 15px 0;
            background: #e2e8f0;
            border-radius: 12px;
            height: 10px;
            overflow: hidden;
            position: relative;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05) inset;
        }

        .progress-bar {
            background: linear-gradient(90deg, #667eea, #764ba2);
            height: 100%;
            transition: width 0.6s cubic-bezier(0.4, 0, 0.2, 1);
            border-radius: 15px;
            position: relative;
            overflow: hidden;
        }

        .progress-bar::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
            animation: shimmer 2s infinite;
        }

        @keyframes shimmer {
            0% {
                transform: translateX(-100%);
            }
            100% {
                transform: translateX(100%);
            }
        }

        .controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
            width: 100%;
        }

        button {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 10px 16px;
            border-radius: 30px;
            font-size: 0.85em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
            position: relative;
            overflow: hidden;
            letter-spacing: 0.3px;
            width: 100%;
        }

        button::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-radius: 50%;
            background: rgba(255,255,255,0.2);
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
        }

        button:hover::before {
            width: 300px;
            height: 300px;
        }

        button:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.4);
        }

        button:active {
            transform: translateY(-1px);
        }

        button:disabled {
            background: linear-gradient(135deg, #cbd5e0, #a0aec0);
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
            opacity: 0.6;
        }

        button:disabled:hover {
            transform: none;
            box-shadow: none;
        }

        #startBtn {
            background: linear-gradient(135deg, #48bb78, #38a169);
            box-shadow: 0 4px 15px rgba(72, 187, 120, 0.3);
        }

        #startBtn:hover {
            box-shadow: 0 8px 25px rgba(72, 187, 120, 0.4);
        }

        #stopBtn {
            background: linear-gradient(135deg, #fc8181, #f56565);
            box-shadow: 0 4px 15px rgba(245, 101, 101, 0.3);
        }

        #stopBtn:hover {
            box-shadow: 0 8px 25px rgba(245, 101, 101, 0.4);
        }

        #repeatBtn {
            background: linear-gradient(135deg, #4299e1, #3182ce);
            box-shadow: 0 4px 15px rgba(66, 153, 225, 0.3);
        }

        #repeatBtn:hover {
            box-shadow: 0 8px 25px rgba(66, 153, 225, 0.4);
        }

        #skipBtn {
            background: linear-gradient(135deg, #ed8936, #dd6b20);
            box-shadow: 0 4px 15px rgba(237, 137, 54, 0.3);
        }

        #skipBtn:hover {
            box-shadow: 0 8px 25px rgba(237, 137, 54, 0.4);
        }

        #resetBtn {
            background: linear-gradient(135deg, #718096, #4a5568);
            box-shadow: 0 4px 15px rgba(113, 128, 150, 0.3);
        }

        #resetBtn:hover {
            box-shadow: 0 8px 25px rgba(113, 128, 150, 0.4);
        }

        .history {
            text-align: left;
            height: 100%;
            display: flex;
            flex-direction: column;
        }

        .history h3 {
            margin-bottom: 15px;
            color: #2d3748;
            font-size: 1.1em;
            font-weight: 800;
            text-align: center;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        #historyList {
            flex: 1;
            overflow-y: auto;
            padding-right: 10px;
        }

        #historyList::-webkit-scrollbar {
            width: 8px;
        }

        #historyList::-webkit-scrollbar-track {
            background: #e2e8f0;
            border-radius: 10px;
        }

        #historyList::-webkit-scrollbar-thumb {
            background: linear-gradient(135deg, #667eea, #764ba2);
            border-radius: 10px;
        }

        #historyList:empty::before {
            content: '×”×™×¡×˜×•×¨×™×™×ª ×”×ª×©×•×‘×•×ª ×ª×•×¤×™×¢ ×›××Ÿ';
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: #a0aec0;
            font-style: italic;
            font-size: 0.85em;
            text-align: center;
            padding: 20px;
        }

        .history-item {
            margin: 8px 0;
            padding: 10px 12px;
            border-radius: 10px;
            border-left: 3px solid #e2e8f0;
            transition: all 0.3s ease;
            animation: historyItemAppear 0.4s ease-out;
            font-size: 0.85em;
        }

        @keyframes historyItemAppear {
            from {
                opacity: 0;
                transform: translateX(-20px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        .history-item:hover {
            transform: translateX(5px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.08);
        }

        .history-item.correct {
            background: linear-gradient(135deg, #f0fff4 0%, #c6f6d5 100%);
            border-left-color: #48bb78;
            border-left-width: 3px;
        }

        .history-item.incorrect {
            background: linear-gradient(135deg, #fed7d7 0%, #feb2b2 100%);
            border-left-color: #f56565;
            border-left-width: 3px;
        }

        .history-item strong {
            font-size: 0.95em;
            display: block;
            margin-bottom: 4px;
        }

        .history-item div {
            font-size: 0.8em;
        }

        .settings {
            margin-top: 15px;
            padding: 15px 20px;
            background: linear-gradient(135deg, #f7fafc 0%, #edf2f7 100%);
            border-radius: 15px;
            text-align: left;
            box-shadow: 0 4px 15px rgba(0,0,0,0.05) inset;
        }

        .settings h3 {
            margin-bottom: 12px;
            color: #2d3748;
            font-size: 0.95em;
            font-weight: 700;
        }

        .setting-item {
            margin: 12px 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 10px;
        }

        .setting-item label {
            font-weight: 600;
            color: #2d3748;
            font-size: 0.8em;
            white-space: nowrap;
        }

        .setting-item input[type="range"] {
            flex: 1;
            height: 8px;
            border-radius: 5px;
            background: #e2e8f0;
            outline: none;
            -webkit-appearance: none;
            appearance: none;
        }

        .setting-item input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea, #764ba2);
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.4);
            transition: all 0.2s ease;
        }

        .setting-item input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.6);
        }

        .setting-item input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea, #764ba2);
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.4);
            border: none;
        }

        .setting-item select {
            padding: 6px 10px;
            border: 2px solid #e2e8f0;
            border-radius: 10px;
            background: white;
            color: #2d3748;
            font-size: 0.75em;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 120px;
        }

        .setting-item select:hover {
            border-color: #667eea;
        }

        .setting-item select:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .setting-item span {
            min-width: 35px;
            text-align: center;
            font-weight: 600;
            color: #667eea;
            font-size: 0.8em;
        }

        .error-message {
            background: linear-gradient(135deg, #fed7d7 0%, #feb2b2 100%);
            color: #c53030;
            padding: 12px 15px;
            border-radius: 12px;
            margin: 10px 0;
            border: 2px solid #f56565;
            font-size: 0.85em;
            font-weight: 600;
            box-shadow: 0 4px 15px rgba(245, 101, 101, 0.2);
            animation: messageSlideIn 0.4s ease-out;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .error-message::before {
            content: 'âš ï¸';
            font-size: 1.2em;
        }

        .success-message {
            background: linear-gradient(135deg, #f0fff4 0%, #c6f6d5 100%);
            color: #22543d;
            padding: 12px 15px;
            border-radius: 12px;
            margin: 10px 0;
            border: 2px solid #48bb78;
            font-size: 0.9em;
            font-weight: 700;
            box-shadow: 0 4px 15px rgba(72, 187, 120, 0.2);
            animation: messageSlideIn 0.4s ease-out;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .success-message::before {
            content: 'âœ“';
            font-size: 1.4em;
            color: #48bb78;
        }

        @keyframes messageSlideIn {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .voice-indicator {
            display: inline-block;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            position: relative;
        }

        .voice-indicator::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            animation: pulse 1.5s ease-in-out infinite;
        }

        .voice-indicator.listening {
            background: #38b2ac;
        }

        .voice-indicator.listening::before {
            background: #38b2ac;
        }

        .voice-indicator.speaking {
            background: #f6ad55;
        }

        .voice-indicator.speaking::before {
            background: #f6ad55;
        }

        .voice-indicator.waiting {
            background: #68d391;
        }

        @keyframes pulse {
            0% { 
                transform: translate(-50%, -50%) scale(1); 
                opacity: 0.8; 
            }
            50% { 
                transform: translate(-50%, -50%) scale(2); 
                opacity: 0; 
            }
            100% { 
                transform: translate(-50%, -50%) scale(1); 
                opacity: 0; 
            }
        }

        .hidden {
            display: none !important;
        }

        /* Responsive Design */
        @media (max-width: 1024px) {
            body {
                flex-direction: column;
                overflow-y: auto;
            }

            .sidebar {
                width: 100%;
                flex-direction: row;
                padding: 15px;
                gap: 15px;
            }

            .logo {
                width: 80px;
            }

            .sidebar-divider {
                width: 2px;
                height: 60px;
                background: linear-gradient(180deg, transparent, #e2e8f0, transparent);
            }

            .controls {
                flex-direction: row;
                flex-wrap: wrap;
                flex: 1;
                justify-content: center;
            }

            button {
                flex: 1;
                min-width: 120px;
            }

            .main-content {
                flex-direction: column;
                overflow-y: visible;
            }

            .history-card {
                width: 100%;
                position: static;
                top: auto;
                max-height: none;
            }

            .manual-input-row {
                flex-direction: column;
                align-items: stretch;
            }

            .manual-input-row button {
                width: 100%;
            }
        }

        @media (max-width: 768px) {
            .sidebar {
                padding: 10px;
                gap: 10px;
            }

            .logo {
                width: 60px;
            }

            button {
                padding: 8px 12px;
                font-size: 0.75em;
                min-width: 100px;
            }

            h1 {
                font-size: 1.3em;
            }

            .question-display {
                font-size: 2em;
                min-height: 60px;
                padding: 15px;
            }
        }

        @media (max-width: 480px) {
            .controls {
                flex-direction: column;
            }

            button {
                width: 100%;
                min-width: unset;
            }

            .question-display {
                font-size: 1.5em;
                min-height: 50px;
                padding: 12px;
            }
        }
    </style>
</head>
<body>
    <div class="sidebar">
        <div class="logo-container">
            <img src="logo.svg" alt="B.Z.I.EDUCATION" class="logo">
        </div>
        
        <div class="sidebar-divider"></div>

        <div class="controls">
            <button id="startBtn" onclick="startSession()">×”×ª×—×œ</button>
            <button id="stopBtn" onclick="stopSession()" disabled>×¢×¦×•×¨</button>
            <button id="repeatBtn" onclick="repeatQuestion()" disabled>×—×–×•×¨</button>
            <button id="skipBtn" onclick="skipQuestion()" disabled>×“×œ×’</button>
            <button id="resetBtn" onclick="resetSession()">××¤×¡</button>
        </div>
    </div>

    <div class="main-content">
        <div class="container">
            <h1>ğŸ¯ ××•×¨×” ×§×•×œ×™ ×œ××ª××˜×™×§×”</h1>
            
            <div id="status" class="status waiting">
                <span class="voice-indicator"></span>
                ××•×›×Ÿ ×œ×”×ª×—×œ×ª ×”×©×™×¢×•×¨
            </div>

            <div id="compatibilityNotice" class="compatibility-notice hidden"></div>

            <div id="questionDisplay" class="question-display">
                ×œ×—×¦×• ×¢×œ "×”×ª×—×œ" ×›×“×™ ×œ×”×ª×—×™×œ ×‘×©×™×¢×•×¨
            </div>

            <div class="progress">
                <div id="progressBar" class="progress-bar" style="width: 0%"></div>
            </div>

            <div id="manualAnswerSection" class="manual-answer">
                <label for="manualAnswerInput">××¤×©×¨ ×œ×¢× ×•×ª ×’× ×‘×”×§×œ×“×”:</label>
                <div class="manual-input-row">
                    <input type="text" id="manualAnswerInput" placeholder="×”×§×œ×™×“×• ××ª ×”×ª×©×•×‘×” ×”××¡×¤×¨×™×ª" disabled>
                    <button id="manualAnswerBtn" onclick="submitManualAnswer()" disabled>×©×œ×™×—×ª ×ª×©×•×‘×”</button>
                </div>
                <p id="manualHint" class="manual-hint">
                    ×× ×”×–×™×”×•×™ ×”×§×•×œ×™ ×œ× ×¢×•×‘×“, ×›×ª×‘×• ××ª ×”×ª×©×•×‘×” ×•×œ×—×¦×• ×¢×œ "×©×œ×™×—×ª ×ª×©×•×‘×”".
                </p>
            </div>

            <div id="errorMessage" class="error-message hidden"></div>
            <div id="successMessage" class="success-message hidden"></div>

            <div class="settings">
                <h3>×”×’×“×¨×•×ª ×§×•×œ</h3>
                <div class="setting-item">
                    <label>××”×™×¨×•×ª ×“×™×‘×•×¨:</label>
                    <input type="range" id="speechRate" min="0.5" max="1.5" step="0.1" value="0.8">
                    <span id="rateValue">0.8</span>
                </div>
                <div class="setting-item">
                    <label>×’×•×‘×” ×§×•×œ:</label>
                    <input type="range" id="speechPitch" min="0.5" max="2" step="0.1" value="1.0">
                    <span id="pitchValue">1.0</span>
                </div>
                <div class="setting-item">
                    <label>×§×•×œ:</label>
                    <select id="voiceSelect">
                        <option value="auto">××•×˜×•××˜×™</option>
                    </select>
                </div>
            </div> 
        </div>

        <div class="history-card">
            <div class="history">
                <h3>×”×™×¡×˜×•×¨×™×™×ª ×ª×©×•×‘×•×ª</h3>
                <div id="historyList"></div>
            </div>
        </div>
    </div>

    <script>
        // Hebrew number mapping
        const hebrewNumbers = {
            '××¤×¡': 0,
            '××—×“': 1,
            '××—×ª': 1,
            '×©× ×™×™×': 2,
            '×©×ª×™×™×': 2,
            '×©×ª×™×': 2,
            '×©×ª×™': 2,
            '×©×œ×•×©': 3,
            '×©×œ×•×©×”': 3,
            '××¨×‘×¢': 4,
            '××¨×‘×¢×”': 4,
            '×—××©': 5,
            '×—××™×©×”': 5,
            '×©×©': 6,
            '×©×™×©×”': 6,
            '×©×‘×¢': 7,
            '×©×‘×¢×”': 7,
            '×©××•× ×”': 8,
            '×ª×©×¢': 9,
            '×ª×©×¢×”': 9,
            '×¢×©×¨': 10,
            '×¢×©×¨×”': 10,
            '××—×ª ×¢×©×¨×”': 11,
            '××—×“ ×¢×©×¨': 11,
            '×©×ª×™× ×¢×©×¨×”': 12,
            '×©× ×™× ×¢×©×¨': 12,
            '×©×œ×•×© ×¢×©×¨×”': 13,
            '×©×œ×•×©×” ×¢×©×¨': 13,
            '××¨×‘×¢ ×¢×©×¨×”': 14,
            '××¨×‘×¢×” ×¢×©×¨': 14,
            '×—××© ×¢×©×¨×”': 15,
            '×—××™×©×” ×¢×©×¨': 15,
            '×©×© ×¢×©×¨×”': 16,
            '×©×™×©×” ×¢×©×¨': 16,
            '×©×‘×¢ ×¢×©×¨×”': 17,
            '×©×‘×¢×” ×¢×©×¨': 17,
            '×©××•× ×” ×¢×©×¨×”': 18,
            '×ª×©×¢ ×¢×©×¨×”': 19,
            '×ª×©×¢×” ×¢×©×¨': 19,
            '×¢×©×¨×™×': 20
        };

        const SpeechRecognitionConstructor = window.SpeechRecognition || window.webkitSpeechRecognition || null;
        const SpeechGrammarListConstructor = window.SpeechGrammarList || window.webkitSpeechGrammarList || null;
        const speechSynthesisSupported = 'speechSynthesis' in window && !!window.speechSynthesis;
        const userAgent = (navigator.userAgent || '').toLowerCase();
        const isAndroid = /android/.test(userAgent);
        const isIOS = /iphone|ipad|ipod/.test(userAgent);
        const isSafari = /safari/.test(userAgent) && !/chrome|chromium|android|edge|opr/.test(userAgent);
        const isOpera = /opr|opera/.test(userAgent);
        let androidPrimeResolver = null;
        const compatibilityNoticeEl = document.getElementById('compatibilityNotice');
        const manualAnswerSection = document.getElementById('manualAnswerSection');
        const manualAnswerInput = document.getElementById('manualAnswerInput');
        const manualAnswerBtn = document.getElementById('manualAnswerBtn');
        const manualHint = document.getElementById('manualHint');
        const compatibilityNotes = new Set();

        function createNumberGrammar() {
            if (!SpeechGrammarListConstructor) {
                return '';
            }

            const uniqueTerms = new Set();
            Object.keys(hebrewNumbers).forEach(term => uniqueTerms.add(term.replace(/\s+/g, ' ')));
            for (let i = 0; i <= 20; i++) {
                uniqueTerms.add(i.toString());
            }
            return `#JSGF V1.0; grammar numbers; public <number> = ${Array.from(uniqueTerms).join(' | ')};`;
        }

        async function primeAndroidRecognition() {
            if (!isAndroid || sessionState.androidPrimed || !speechRecognition) {
                return;
            }

            if (sessionState.isPrimingRecognition) {
                return;
            }

            console.log('ğŸ”„ Priming speech recognition for Android');
            sessionState.isPrimingRecognition = true;
            sessionState.skipRecognitionResults = true;
            sessionState.waitingForAnswer = false;

            await new Promise((resolve) => {
                androidPrimeResolver = () => {
                    if (androidPrimeResolver) {
                        androidPrimeResolver = null;
                    }
                    resolve();
                };

                try {
                    speechRecognition.start();
                    setTimeout(() => {
                        try {
                            speechRecognition.stop();
                        } catch (stopError) {
                            console.warn('Error stopping priming recognition:', stopError);
                            if (androidPrimeResolver) {
                                androidPrimeResolver();
                            }
                        }
                    }, 600);
                } catch (startError) {
                    console.warn('Error starting priming recognition:', startError);
                    if (androidPrimeResolver) {
                        androidPrimeResolver();
                    }
                }
            });

            sessionState.isPrimingRecognition = false;
            sessionState.skipRecognitionResults = false;
            sessionState.androidPrimed = true;
            sessionState.waitingForAnswer = false;
            console.log('âœ… Android speech recognition primed');
        }

        function getHebrewNumberValue(phrase) {
            if (!phrase) {
                return null;
            }

            const base = phrase.trim();
            if (!base) {
                return null;
            }

            const candidates = new Set([base]);
            const prefixPatterns = ['×”', '×•', '×•×”', '×•Ö¼', '×•Ö°', '×•Ö¸'];

            prefixPatterns.forEach(prefix => {
                if (base.startsWith(prefix)) {
                    candidates.add(base.slice(prefix.length));
                }
            });

            for (const candidate of candidates) {
                const cleaned = candidate.trim();
                if (cleaned && hebrewNumbers.hasOwnProperty(cleaned)) {
                    return hebrewNumbers[cleaned];
                }
            }

            return null;
        }

        let microphoneStream = null;
        let microphonePermissionState = 'prompt';
        let microphoneAccessPromise = null;

        if (navigator.permissions && navigator.permissions.query) {
            try {
                navigator.permissions.query({ name: 'microphone' }).then(status => {
                    microphonePermissionState = status.state;
                    status.onchange = () => {
                        microphonePermissionState = status.state;
                    };
                }).catch(error => {
                    console.warn('Microphone permission query failed:', error);
                });
            } catch (error) {
                console.warn('Microphone permission monitoring unavailable:', error);
            }
        }

        async function ensureMicrophoneAccess(userInitiated = false) {
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                showError('×”×“×¤×“×¤×Ÿ ×©×œ×š ×œ× ×ª×•××š ×‘×’×™×©×” ×œ××™×§×¨×•×¤×•×Ÿ.');
                return false;
            }

            if (!window.isSecureContext) {
                showError('×›×“×™ ×œ×”×©×ª××© ×‘××™×§×¨×•×¤×•×Ÿ, ×¤×ª×—×• ××ª ×”×“×£ ×“×¨×š https:// ××• localhost ×‘××§×•× file://.');
                return false;
            }

            if (microphoneAccessPromise) {
                return microphoneAccessPromise;
            }

            if (microphoneStream) {
                const active = microphoneStream.getTracks().some(track => track.readyState === 'live');
                if (active) {
                    return true;
                }
            }

            if (microphonePermissionState === 'denied') {
                showError('×”×’×™×©×” ×œ××™×§×¨×•×¤×•×Ÿ × ×“×—×ª×”. ××¤×©×¨×• ××•×ª×” ×‘×”×’×“×¨×•×ª ×”×“×¤×“×¤×Ÿ ×•× ×¡×• ×©×•×‘.');
                return false;
            }

            microphoneAccessPromise = navigator.mediaDevices.getUserMedia({
                audio: {
                    channelCount: 1,
                    echoCancellation: true,
                    noiseSuppression: true,
                    autoGainControl: true
                }
            }).then(stream => {
                microphoneStream = stream;
                microphonePermissionState = 'granted';
                return true;
            }).catch(error => {
                console.error('Microphone access error:', error);
                microphonePermissionState = 'denied';
                if (userInitiated) {
                    showError('×”×’×™×©×” ×œ××™×§×¨×•×¤×•×Ÿ × ×“×—×ª×”. ××¤×©×¨×• ××•×ª×” ×•× ×¡×• ×©×•×‘.');
                }
                return false;
            }).finally(() => {
                microphoneAccessPromise = null;
            });

            return microphoneAccessPromise;
        }

        function renderCompatibilityNotes() {
            if (!compatibilityNoticeEl) {
                return;
            }
            if (compatibilityNotes.size === 0) {
                compatibilityNoticeEl.classList.add('hidden');
                compatibilityNoticeEl.textContent = '';
            } else {
                compatibilityNoticeEl.classList.remove('hidden');
                compatibilityNoticeEl.innerHTML = Array.from(compatibilityNotes)
                    .map(note => `<span>${note}</span>`)
                    .join('<br>');
            }
        }

        function addCompatibilityNote(note) {
            if (!note) return;
            compatibilityNotes.add(note);
            renderCompatibilityNotes();
        }

        function removeCompatibilityNote(note) {
            if (!note) return;
            compatibilityNotes.delete(note);
            renderCompatibilityNotes();
        }

        function setManualAnswerEnabled(enabled) {
            if (!manualAnswerInput || !manualAnswerBtn) return;
            const allow = !!enabled && sessionState.isActive && !sessionState.processingAnswer;
            manualAnswerInput.disabled = !allow;
            manualAnswerBtn.disabled = !allow;
        }

        function disableSpeechRecognition(reason) {
            sessionState.voiceInputSupported = false;
            sessionState.isListening = false;
            sessionState.waitingForAnswer = false;
            sessionState.microphoneReady = false;
            sessionState.isPrimingRecognition = false;
            sessionState.skipRecognitionResults = false;
            sessionState.androidPrimed = false;
            if (speechRecognition) {
                try {
                    speechRecognition.stop();
                } catch (error) {
                    console.warn('Error stopping speech recognition during disable:', error);
                }
            }
            speechRecognition = null;
            if (reason) {
                addCompatibilityNote(reason);
            }
            if (manualHint) {
                manualHint.textContent = '×”×§×œ×™×“×• ××ª ×”×ª×©×•×‘×” ×•×œ×—×¦×• "×©×œ×™×—×ª ×ª×©×•×‘×”" ×œ×”××©×š ×”×ª×¨×’×•×œ.';
            }
            if (sessionState.isActive) {
                setManualAnswerEnabled(true);
                updateStatus('×”×§×œ×™×“×• ××ª ×”×ª×©×•×‘×” ×•×œ×—×¦×• "×©×œ×™×—×ª ×ª×©×•×‘×”"', 'waiting');
            }
        }

        function submitManualAnswer() {
            if (!sessionState.isActive || !sessionState.currentQuestion) {
                showError('××™×Ÿ ×©××œ×” ×¤×¢×™×œ×” ×›×¨×’×¢.');
                return;
            }
            const value = manualAnswerInput.value.trim();
            if (!value) {
                showError('×× × ×”×§×œ×™×“×• ×ª×©×•×‘×” ×•×œ××—×¨ ××›×Ÿ ×œ×—×¦×• ×¢×œ "×©×œ×™×—×ª ×ª×©×•×‘×”".');
                return;
            }
            processAnswer(value, []);
            manualAnswerInput.value = '';
            setManualAnswerEnabled(false);
        }

        // Question sets
        const questions = {
            label1: [
                { question: "2 + 1", answer: 3, text: "×©×ª×™×™× ×•×¢×•×“ ××—×“" },
                { question: "5 + 1", answer: 6, text: "×—××© ×•×¢×•×“ ××—×“" },
                { question: "7 + 1", answer: 8, text: "×©×‘×¢ ×•×¢×•×“ ××—×“" },
                { question: "3 + 1", answer: 4, text: "×©×œ×•×© ×•×¢×•×“ ××—×“" },
                { question: "9 + 1", answer: 10, text: "×ª×©×¢ ×•×¢×•×“ ××—×“" }
            ],
            label2: [
                { question: "2 + 2", answer: 4, text: "×©×ª×™×™× ×•×¢×•×“ ×©×ª×™×™×" },
                { question: "5 + 2", answer: 7, text: "×—××© ×•×¢×•×“ ×©×ª×™×™×" },
                { question: "7 + 2", answer: 9, text: "×©×‘×¢ ×•×¢×•×“ ×©×ª×™×™×" },
                { question: "4 + 2", answer: 6, text: "××¨×‘×¢ ×•×¢×•×“ ×©×ª×™×™×" },
                { question: "9 + 2", answer: 11, text: "×ª×©×¢ ×•×¢×•×“ ×©×ª×™×™×" }
            ]
        };

        // Application state
        let sessionState = {
            currentLabel: 1,
            currentQuestionIndex: 0,
            errors: [],
            isActive: false,
            isListening: false,
            isSpeaking: false,
            currentQuestion: null,
            sessionHistory: [],
            processingAnswer: false,
            waitingForAnswer: false,
            microphoneReady: false,
            isPrimingRecognition: false,
            skipRecognitionResults: false,
            androidPrimed: false,
            voiceInputSupported: !!SpeechRecognitionConstructor,
            voiceOutputSupported: speechSynthesisSupported
        };

        // Voice services
        let speechSynthesis = speechSynthesisSupported ? window.speechSynthesis : null;
        let speechRecognition = null;
        let currentVoice = null;

        function startListeningForAnswer(delay = 0) {
            if (!sessionState.voiceInputSupported || !speechRecognition || !sessionState.isActive) {
                return;
            }

            const start = async () => {
                if (!sessionState.isActive || sessionState.processingAnswer || sessionState.isListening || sessionState.isSpeaking || sessionState.isPrimingRecognition) {
                    return;
                }

                if (!sessionState.microphoneReady) {
                    const accessGranted = await ensureMicrophoneAccess(false);
                    if (!accessGranted) {
                        console.warn('Microphone not ready, cannot start recognition.');
                        return;
                    }
                    sessionState.microphoneReady = true;
                }

                if (isAndroid && !sessionState.androidPrimed) {
                    await primeAndroidRecognition();
                }

                try {
                    speechRecognition.start();
                    sessionState.waitingForAnswer = true;
                } catch (error) {
                    if (error.name !== 'InvalidStateError') {
                        console.error('Error starting speech recognition:', error);
                        disableSpeechRecognition('×œ× × ×™×ª×Ÿ ×œ×”×¤×¢×™×œ ×–×™×”×•×™ ×“×™×‘×•×¨ ×‘×“×¤×“×¤×Ÿ ×–×”. × ×™×ª×Ÿ ×œ×”×§×œ×™×“ ×ª×©×•×‘×•×ª ×‘××§×•×.');
                    }
                }
            };

            if (delay > 0) {
                setTimeout(() => {
                    start();
                }, delay);
            } else {
                start();
            }
        }

        // Initialize voice services
        function initializeVoiceServices() {
            // Initialize speech recognition
            sessionState.voiceInputSupported = !!SpeechRecognitionConstructor;
            sessionState.voiceOutputSupported = speechSynthesisSupported;

            if (!sessionState.voiceInputSupported) {
                addCompatibilityNote('×”×“×¤×“×¤×Ÿ ×œ× ×ª×•××š ×‘×–×™×”×•×™ ×“×™×‘×•×¨. × ×™×ª×Ÿ ×œ×”×©×™×‘ ×“×¨×š ×”×”×§×œ×“×” ××• ×œ×”×©×ª××© ×‘-Chrome/Edge.');
                speechRecognition = null;
                return true;
            }

            speechRecognition = new SpeechRecognitionConstructor();

            if (SpeechGrammarListConstructor) {
                try {
                    const grammarList = new SpeechGrammarListConstructor();
                    const grammar = createNumberGrammar();
                    if (grammar) {
                        grammarList.addFromString(grammar, 1);
                        speechRecognition.grammars = grammarList;
                    }
                } catch (error) {
                    console.warn('Could not apply speech grammar:', error);
                }
            }

            speechRecognition.lang = 'he-IL';
            speechRecognition.continuous = false;
            speechRecognition.interimResults = false;
            speechRecognition.maxAlternatives = 5;

            speechRecognition.onstart = () => {
                console.log('âœ… Speech recognition STARTED');
                sessionState.isListening = true;
                if (sessionState.isPrimingRecognition) {
                    console.log('âš™ï¸ Speech recognition priming in progress');
                    return;
                }
                sessionState.waitingForAnswer = true;
                updateStatus('×××–×™×Ÿ ×œ×ª×©×•×‘×” ×©×œ×š...', 'listening');
            };

            speechRecognition.onresult = (event) => {
                console.log('âœ… Speech recognition RESULT:', event.results);
                if (sessionState.processingAnswer) {
                    console.log('Ignoring result while processing answer');
                    return;
                }
                if (!sessionState.isActive) {
                    console.log('Session not active, ignoring result');
                    return;
                }
                if (sessionState.isPrimingRecognition || sessionState.skipRecognitionResults) {
                    console.log('Skipping recognition result (priming/warmup).');
                    return;
                }
                // Get the final result (not interim)
                for (let i = event.results.length - 1; i >= 0; i--) {
                    const res = event.results[i];
                    if (res.isFinal) {
                        const transcripts = [];
                        for (let j = 0; j < res.length; j++) {
                            const altTranscript = res[j].transcript.toLowerCase().trim();
                            if (altTranscript && !transcripts.includes(altTranscript)) {
                                transcripts.push(altTranscript);
                            }
                        }
                        if (transcripts.length === 0) {
                            console.warn('Final result received without transcript content', res);
                            return;
                        }
                        console.log('âœ… Final transcript options:', transcripts);
                        if (!sessionState.currentQuestion) {
                            console.log('No current question set, ignoring late result');
                            return;
                        }
                        // Stop recognition before processing to avoid duplicate results
                        sessionState.isListening = false;
                        sessionState.waitingForAnswer = false;
                        try { 
                            if (speechRecognition) {
                                speechRecognition.stop(); 
                            }
                        } catch (error) {
                            console.error('Error stopping recognition:', error);
                        }
                        const primaryTranscript = transcripts[0];
                        const alternateTranscripts = transcripts.slice(1);
                        processAnswer(primaryTranscript, alternateTranscripts);
                        break;
                    }
                }
            };

            speechRecognition.onerror = (event) => {
                console.error('âŒ Speech recognition ERROR:', event.error);
                sessionState.isListening = false;
                if (sessionState.isPrimingRecognition) {
                    console.warn('Speech recognition error during priming:', event.error);
                    sessionState.isPrimingRecognition = false;
                    sessionState.skipRecognitionResults = false;
                    sessionState.waitingForAnswer = false;
                    sessionState.androidPrimed = false;
                    if (androidPrimeResolver) {
                        const resolver = androidPrimeResolver;
                        androidPrimeResolver = null;
                        resolver();
                    }
                    return;
                }
                sessionState.waitingForAnswer = false;
                
                // Specific error handling with user-friendly messages
                const errorMessages = {
                    'no-speech': '×œ× ×©××¢×ª×™ ×ª×©×•×‘×”. × ×¡×• ×©×•×‘.',
                    'network': '×‘×¢×™×” ×‘×—×™×‘×•×¨ ×”××™× ×˜×¨× ×˜. ×‘×“×§×• ××ª ×”×—×™×‘×•×¨.',
                    'not-allowed': '××™×Ÿ ×’×™×©×” ×œ××™×§×¨×•×¤×•×Ÿ. ××¤×©×¨×• ×’×™×©×” ×‘×”×’×“×¨×•×ª ×”×“×¤×“×¤×Ÿ.',
                    'audio-capture': '×œ× × ××¦× ××™×§×¨×•×¤×•×Ÿ. ×‘×“×§×• ××ª ×”×—×™×‘×•×¨.',
                    'service-not-allowed': '×©×™×¨×•×ª ×–×™×”×•×™ ×”×“×™×‘×•×¨ ××™× ×• ×–××™×Ÿ. × ×¡×• ×©×•×‘ ×××•×—×¨ ×™×•×ª×¨.',
                    'aborted': '×–×™×”×•×™ ×”×“×™×‘×•×¨ ×”×•×¤×¡×§.',
                    'bad-grammar': '×©×’×™××” ×‘×“×§×“×•×§.'
                };
                
                const errorMessage = errorMessages[event.error] || `×©×’×™××ª ×–×™×”×•×™: ${event.error}`;
                showError(errorMessage);
                
                // Don't automatically retry - let the user click skip or stop if needed
                // Automatic retries were causing endless loops
                updateStatus('×©×’×™××ª ×–×™×”×•×™', 'waiting');
                
                const recoverableErrors = ['no-speech', 'aborted'];
                if (sessionState.isActive && recoverableErrors.includes(event.error)) {
                    startListeningForAnswer(800);
                } else if (['service-not-allowed', 'not-allowed', 'audio-capture'].includes(event.error)) {
                    disableSpeechRecognition('×”×’×™×©×” ×œ×–×™×”×•×™ ×“×™×‘×•×¨ × ×—×¡××”. ×”×©×ª××©×• ×‘×”×§×œ×“×ª ×ª×©×•×‘×” ××• ×”×¤×¢×™×œ×• ×“×¤×“×¤×Ÿ ×ª×•××š.');
                } else if (event.error === 'network') {
                    addCompatibilityNote('×©×™×¨×•×ª ×–×™×”×•×™ ×”×“×™×‘×•×¨ ××™× ×• ×–××™×Ÿ ×›×¨×’×¢ (×©×’×™××ª ×¨×©×ª). × ×™×ª×Ÿ ×œ×”××©×™×š ×‘×”×§×œ×“×”.');
                    setManualAnswerEnabled(true);
                }
            };

            speechRecognition.onend = () => {
                console.log('âœ… Speech recognition ENDED');
                sessionState.isListening = false;
                if (sessionState.isPrimingRecognition) {
                    console.log('âœ… Speech recognition priming session ended');
                    sessionState.isPrimingRecognition = false;
                    sessionState.skipRecognitionResults = false;
                    sessionState.waitingForAnswer = false;
                    sessionState.androidPrimed = true;
                    if (androidPrimeResolver) {
                        const resolver = androidPrimeResolver;
                        androidPrimeResolver = null;
                        resolver();
                    }
                    return;
                }
                if (sessionState.isActive && sessionState.waitingForAnswer && !sessionState.processingAnswer) {
                    startListeningForAnswer(500);
                }
            };

            // Load available voices
            if (speechSynthesis) {
                loadVoices();
                speechSynthesis.onvoiceschanged = loadVoices;
            } else {
                addCompatibilityNote('×”×“×¤×“×¤×Ÿ ×œ× ×ª×•××š ×‘×”×§×¨××ª ×§×•×œ. ×”×ª×¨×’×™×œ×™× ×™×•×¦×’×• ×›×˜×§×¡×˜ ×‘×œ×‘×“.');
            }

            return true;
        }

        // Load available voices
        function loadVoices() {
            if (!speechSynthesis) {
                const voiceSelect = document.getElementById('voiceSelect');
                if (voiceSelect) {
                    voiceSelect.innerHTML = '<option value="auto">××™×Ÿ ×§×•×œ×•×ª ×–××™× ×™×</option>';
                    voiceSelect.disabled = true;
                }
                return;
            }

            const voices = speechSynthesis.getVoices();
            const voiceSelect = document.getElementById('voiceSelect');
            
            // Clear existing options except the first one
            voiceSelect.innerHTML = '<option value="auto">××•×˜×•××˜×™</option>';
            
            voices.forEach((voice, index) => {
                const lang = voice.lang.toLowerCase();
                if (lang.startsWith('he') || lang.startsWith('iw')) {
                    const option = document.createElement('option');
                    option.value = index;
                    option.textContent = `${voice.name} (${voice.lang})`;
                    voiceSelect.appendChild(option);
                }
            });
        }

        // Parse Hebrew number from speech
        function parseHebrewNumber(speech) {
            if (!speech || typeof speech !== 'string') {
                return null;
            }
            
            const normalizedInput = speech
                .trim()
                .replace(/[.,!?]/g, ' ')
                .replace(/[-Ö¾]/g, ' ')
                .replace(/[\"'×´â€œâ€×³â€™(){}\[\]:;]/g, ' ')
                .replace(/[\u0591-\u05C7]/g, '')
                .replace(/[\u200e\u200f]/g, '')
                .replace(/\s+/g, ' ')
                .toLowerCase();

            if (!normalizedInput) {
                return null;
            }
            
            // If transcript contains digits (e.g., "10"), parse directly
            const digitMatch = normalizedInput.match(/\d+/);
            if (digitMatch) {
                const n = parseInt(digitMatch[0], 10);
                if (!isNaN(n) && n >= 0 && n <= 100) {
                    return n;
                }
            }
            
            // Try direct match of the full phrase
            const directValue = getHebrewNumberValue(normalizedInput);
            if (directValue !== null) {
                return directValue;
            }
            
            // Check all contiguous word segments for a match
            const words = normalizedInput.split(' ');
            for (let start = 0; start < words.length; start++) {
                for (let end = words.length; end > start; end--) {
                    const chunk = words.slice(start, end).join(' ');
                    const value = getHebrewNumberValue(chunk);
                    if (value !== null) {
                        return value;
                    }
                }
            }
            
            return null;
        }

        // Speak text in Hebrew
        function speak(text) {
            return new Promise((resolve) => {
                if (!speechSynthesis) {
                    resolve();
                    return;
                }

                const utterance = new SpeechSynthesisUtterance(text);
                utterance.lang = 'he-IL';
                utterance.rate = parseFloat(document.getElementById('speechRate').value);
                utterance.pitch = parseFloat(document.getElementById('speechPitch').value);
                
            const voiceIndex = document.getElementById('voiceSelect').value;
            const voices = speechSynthesis.getVoices();
            if (voiceIndex !== 'auto' && voices[voiceIndex]) {
                utterance.voice = voices[voiceIndex];
            }

                utterance.onstart = () => {
                    sessionState.isSpeaking = true;
                    updateStatus('×§×•×¨× ××ª ×”×©××œ×”...', 'speaking');
                };

                utterance.onend = () => {
                    sessionState.isSpeaking = false;
                    updateStatus('××•×›×Ÿ ×œ×ª×©×•×‘×”', 'waiting');
                    resolve();
                };

                utterance.onerror = (event) => {
                    console.error('Speech synthesis error:', event.error);
                    sessionState.isSpeaking = false;
                    updateStatus('×©×’×™××ª ×”×¤×§×ª ×“×™×‘×•×¨', 'waiting');
                    resolve();
                };

                speechSynthesis.speak(utterance);
            });
        }

        // Update status display
        function updateStatus(message, type) {
            const statusEl = document.getElementById('status');
            statusEl.className = `status ${type}`;
            statusEl.innerHTML = `<span class="voice-indicator ${type}"></span>${message}`;
        }

        // Show error message
        function showError(message) {
            const errorEl = document.getElementById('errorMessage');
            errorEl.textContent = message;
            errorEl.classList.remove('hidden');
            setTimeout(() => {
                errorEl.classList.add('hidden');
            }, 5000);
        }

        // Show success message
        function showSuccess(message) {
            const successEl = document.getElementById('successMessage');
            successEl.textContent = message;
            successEl.classList.remove('hidden');
            setTimeout(() => {
                successEl.classList.add('hidden');
            }, 5000);
        }

        // Update progress bar
        function updateProgress() {
            const totalQuestions = questions[`label${sessionState.currentLabel}`].length;
            const progress = ((sessionState.currentQuestionIndex) / totalQuestions) * 100;
            document.getElementById('progressBar').style.width = `${progress}%`;
        }

        // Add item to history
        function addToHistory(question, userAnswer, correctAnswer, isCorrect) {
            const historyList = document.getElementById('historyList');
            const item = document.createElement('div');
            item.className = `history-item ${isCorrect ? 'correct' : 'incorrect'}`;
            
            // Create elements safely to prevent XSS
            const strong = document.createElement('strong');
            strong.textContent = question;
            
            const questionDiv = document.createElement('div');
            questionDiv.appendChild(strong);
            
            const detailsDiv = document.createElement('div');
            detailsDiv.textContent = `×”×ª×©×•×‘×” ×©×œ×š: ${userAnswer} | ×”×ª×©×•×‘×” ×”× ×›×•× ×”: ${correctAnswer} ${isCorrect ? 'âœ“' : 'âœ—'}`;
            
            item.appendChild(questionDiv);
            item.appendChild(detailsDiv);
            
            historyList.insertBefore(item, historyList.firstChild);
            sessionState.sessionHistory.push({
                question, userAnswer, correctAnswer, isCorrect,
                timestamp: new Date().toLocaleTimeString()
            });
        }

        // Process user answer
        function processAnswer(speech, alternatives = []) {
            // Prevent multiple rapid calls
            if (sessionState.processingAnswer) {
                console.log('Already processing answer, ignoring duplicate');
                return;
            }
            sessionState.processingAnswer = true;
            setManualAnswerEnabled(false);
            // Pause recognition while processing
            try { 
                if (sessionState.isListening && speechRecognition) {
                    speechRecognition.stop(); 
                }
            } catch (error) {
                console.error('Error stopping speech recognition:', error);
            }
            sessionState.waitingForAnswer = false;
            
            let recognizedSpeech = speech;
            let userAnswer = parseHebrewNumber(recognizedSpeech);

            if (userAnswer === null && Array.isArray(alternatives)) {
                for (const alt of alternatives) {
                    const parsedAlt = parseHebrewNumber(alt);
                    if (parsedAlt !== null) {
                        recognizedSpeech = alt;
                        userAnswer = parsedAlt;
                        break;
                    }
                }
            }

            if (userAnswer === null && Array.isArray(alternatives)) {
                for (const alt of alternatives) {
                    const words = alt.split(' ');
                    for (const word of words) {
                        const parsedWord = parseHebrewNumber(word);
                        if (parsedWord !== null) {
                            recognizedSpeech = word;
                            userAnswer = parsedWord;
                            break;
                        }
                    }
                    if (userAnswer !== null) {
                        break;
                    }
                }
            }

            const currentQuestion = sessionState.currentQuestion;
            
            console.log('Processing answer:', userAnswer, 'for question:', currentQuestion.question, 'Recognized speech:', recognizedSpeech, 'Alternatives:', alternatives);
            
            if (userAnswer === null) {
                const displaySpeech = speech || alternatives?.[0] || 'â€”';
                showError(`×œ× × ×™×ª×Ÿ ×”×™×” ×œ×–×”×•×ª ××ª ×”××¡×¤×¨ (×–×•×”×”: "${displaySpeech}"). ×œ×—×¦×• ×¢×œ "×“×œ×’" ××• ×××¨×• ××ª ×”×ª×©×•×‘×” ×‘×‘×™×¨×•×¨.`);
                sessionState.processingAnswer = false;
                sessionState.waitingForAnswer = true;
                setManualAnswerEnabled(true);
                updateStatus('××•×›×Ÿ ×œ×ª×©×•×‘×”', 'waiting');
                startListeningForAnswer(800);
                return;
            }

            const isCorrect = userAnswer === currentQuestion.answer;
            
            addToHistory(currentQuestion.question, userAnswer, currentQuestion.answer, isCorrect);
            
            if (!isCorrect) {
                sessionState.errors.push(currentQuestion);
                showError(`×˜×¢×•×ª! ×”×ª×©×•×‘×” ×”× ×›×•× ×”: ${currentQuestion.answer}`);
            } else {
                showSuccess('× ×›×•×Ÿ!');
            }

            // Move to next question
            sessionState.currentQuestionIndex++;
            updateProgress();
            
            setTimeout(() => {
                sessionState.processingAnswer = false;
                setManualAnswerEnabled(sessionState.isActive);
                if (sessionState.isActive) {
                    if (sessionState.currentQuestionIndex < questions[`label${sessionState.currentLabel}`].length) {
                        askCurrentQuestion();
                    } else {
                        completeCurrentLabel();
                    }
                }
            }, 2000);
        }

        // Ask current question
        async function askCurrentQuestion() {
            console.log('Asking question:', sessionState.currentQuestionIndex, 'of', questions[`label${sessionState.currentLabel}`].length);
            
            const currentQuestions = questions[`label${sessionState.currentLabel}`];
            if (sessionState.currentQuestionIndex >= currentQuestions.length) {
                console.log('Index at end of questions, completing label');
                await completeCurrentLabel();
                return;
            }
            sessionState.currentQuestion = currentQuestions[sessionState.currentQuestionIndex];
            sessionState.processingAnswer = false;
            sessionState.waitingForAnswer = false;
            setManualAnswerEnabled(false);
            
            document.getElementById('questionDisplay').textContent = sessionState.currentQuestion.question;
            if (manualAnswerInput) {
                manualAnswerInput.value = '';
            }
            
            await speak(sessionState.currentQuestion.text);

            if (!sessionState.voiceInputSupported) {
                updateStatus('×”×§×œ×™×“×• ××ª ×”×ª×©×•×‘×” ×•×œ×—×¦×• "×©×œ×™×—×ª ×ª×©×•×‘×”"', 'waiting');
                if (manualHint) {
                    manualHint.textContent = '×”×§×œ×™×“×• ××ª ×”×ª×©×•×‘×” ×•×œ×—×¦×• "×©×œ×™×—×ª ×ª×©×•×‘×”" ×›×“×™ ×œ×”××©×™×š.';
                }
                setManualAnswerEnabled(true);
                return;
            }
            
            // Start listening for answer (only if not already listening)
            setTimeout(() => {
                if (!sessionState.isActive) {
                    return;
                }
                if (sessionState.isListening) {
                    console.log('Speech recognition already running, waiting for answer');
                    sessionState.waitingForAnswer = true;
                    return;
                }
                console.log('Starting speech recognition...');
                startListeningForAnswer();
            }, 1000);

            if (manualHint) {
                manualHint.textContent = '××¤×©×¨ ×œ×¢× ×•×ª ×‘×§×•×œ ××• ×œ×”×§×œ×™×“ ××ª ×”×ª×©×•×‘×” ×•×œ×œ×—×•×¥ "×©×œ×™×—×ª ×ª×©×•×‘×”".';
            }
            setManualAnswerEnabled(true);
        }

        // Complete current label
        async function completeCurrentLabel() {
            const totalQuestions = questions[`label${sessionState.currentLabel}`].length;
            const errorCount = sessionState.errors.length;
            sessionState.waitingForAnswer = false;
            
            // Announce statistics
            let message = `×”×™×• ×‘×¡×š ×”×›×•×œ ${totalQuestions} ×©××œ×•×ª, ××¡×¤×¨ ×”×ª×©×•×‘×•×ª ×”×œ× × ×›×•× ×•×ª: ${errorCount}.`;
            await speak(message);
            
            // If there were errors, repeat the label according to README requirements
            if (errorCount > 0) {
                await speak('×‘×•××• × ×—×–×•×¨ ×¢×œ ×”×ª×¨×’×™×œ×™× ×”××œ×”.');
                // Announce incorrect answers
                for (const error of sessionState.errors) {
                    await speak(`${error.text}. ×”×ª×©×•×‘×” ×”× ×›×•× ×” ×”×™× ${error.answer}`);
                }
                
                // Clear errors and restart current label
                sessionState.errors = [];
                sessionState.currentQuestionIndex = 0;
                updateProgress();
                setTimeout(() => {
                    if (sessionState.isActive) {
                        askCurrentQuestion();
                    }
                }, 2000);
            } else {
                // No errors - proceed to next label or finish
                sessionState.errors = [];
                
                if (sessionState.currentLabel === 1) {
                    await speak('×¢×•×‘×¨×™× ×œ×¨××” ×”×‘××”.');
                    sessionState.currentLabel = 2;
                    sessionState.currentQuestionIndex = 0;
                    updateProgress();
                    setTimeout(() => {
                        if (sessionState.isActive) {
                            askCurrentQuestion();
                        }
                    }, 2000);
                } else {
                    await speak('×¢×‘×•×“×” ××¦×•×™× ×ª!');
                    showSuccess('×¢×‘×•×“×” ××¦×•×™× ×ª!');
                    sessionState.isActive = false;
                    updateStatus('×”×©×™×¢×•×¨ ×”×¡×ª×™×™×!', 'waiting');
                    document.getElementById('startBtn').disabled = false;
                    document.getElementById('stopBtn').disabled = true;
                    document.getElementById('skipBtn').disabled = true;
                    saveSession();
                }
            }
        }

        // Start session
        async function startSession() {
            if (!initializeVoiceServices()) {
                return;
            }

            if (sessionState.voiceInputSupported) {
                const hasMic = await ensureMicrophoneAccess(true);
                if (!hasMic) {
                    updateStatus('× ×“×¨×© ××™×§×¨×•×¤×•×Ÿ ×¤×¢×™×œ ×œ×”×ª×—×œ×ª ×”×©×™×¢×•×¨', 'waiting');
                    return;
                }
                sessionState.microphoneReady = true;

                if (isAndroid) {
                    await primeAndroidRecognition();
                }
            } else {
                sessionState.microphoneReady = false;
                addCompatibilityNote('×”×××–×™×Ÿ ×”×§×•×œ×™ ×œ× ×–××™×Ÿ. ×”×©×ª××©×• ×‘×”×§×œ×“×ª ×ª×©×•×‘×”.');
            }

            // Load saved session if exists
            loadSession();
            
            sessionState.isActive = true;
            sessionState.currentLabel = 1;
            sessionState.currentQuestionIndex = 0;
            sessionState.errors = [];
            sessionState.sessionHistory = [];
            sessionState.processingAnswer = false;
            sessionState.waitingForAnswer = false;
            sessionState.isPrimingRecognition = false;
            sessionState.skipRecognitionResults = false;
            sessionState.androidPrimed = isAndroid ? sessionState.androidPrimed : false;
            
            document.getElementById('startBtn').disabled = true;
            document.getElementById('stopBtn').disabled = false;
            document.getElementById('repeatBtn').disabled = false;
            document.getElementById('skipBtn').disabled = false;
            document.getElementById('historyList').innerHTML = '';
            setManualAnswerEnabled(true);
            if (manualHint) {
                manualHint.textContent = sessionState.voiceInputSupported
                    ? '××¤×©×¨ ×’× ×œ×”×§×œ×™×“ ××ª ×”×ª×©×•×‘×” ×•×œ×œ×—×•×¥ "×©×œ×™×—×ª ×ª×©×•×‘×”" ×‘×›×œ ×¨×’×¢.'
                    : '×”×§×œ×™×“×• ××ª ×”×ª×©×•×‘×” ×•×œ×—×¦×• "×©×œ×™×—×ª ×ª×©×•×‘×”" ×›×“×™ ×œ×”××©×™×š.';
            }
            
            updateStatus('××ª×—×™×œ×™× ××ª ×”×©×™×¢×•×¨...', 'waiting');
            updateProgress();
            
            await speak('×©×œ×•×! ×‘×•××• × ×¤×ª×•×¨ ×ª×¨×’×™×œ×™×.');
            await askCurrentQuestion();
        }

        // Repeat current question
        function repeatQuestion() {
            if (!sessionState.isActive || !sessionState.currentQuestion) return;
            
            console.log('Repeating question');
            
            // Stop any ongoing speech recognition
            if (speechRecognition && sessionState.isListening) {
                try {
                    speechRecognition.stop();
                } catch (error) {
                    console.error('Error stopping recognition:', error);
                }
            }
            
            sessionState.processingAnswer = false;
            sessionState.waitingForAnswer = false;
            
            // Ask the same question again
            askCurrentQuestion();
        }

        // Skip current question
        function skipQuestion() {
            if (!sessionState.isActive || !sessionState.currentQuestion) return;
            
            console.log('Skipping question');
            
            // Stop any ongoing speech recognition
            if (speechRecognition && sessionState.isListening) {
                try {
                    speechRecognition.stop();
                } catch (error) {
                    console.error('Error stopping recognition:', error);
                }
            }
            
            sessionState.processingAnswer = false;
            sessionState.waitingForAnswer = false;
            
            // Mark as incorrect and add to errors
            const currentQuestion = sessionState.currentQuestion;
            addToHistory(currentQuestion.question, '×“×™×œ×’', currentQuestion.answer, false);
            sessionState.errors.push(currentQuestion);
            
            showError(`×”×ª×¨×’×™×œ ×“×•×œ×’. ×”×ª×©×•×‘×” ×”× ×›×•× ×”: ${currentQuestion.answer}`);
            
            // Move to next question
            sessionState.currentQuestionIndex++;
            updateProgress();
            
            setTimeout(() => {
                if (sessionState.isActive) {
                    if (sessionState.currentQuestionIndex < questions[`label${sessionState.currentLabel}`].length) {
                        askCurrentQuestion();
                    } else {
                        completeCurrentLabel();
                    }
                }
            }, 2000);
        }

        // Stop session
        function stopSession() {
            sessionState.isActive = false;
            sessionState.isListening = false;
            sessionState.isSpeaking = false;
            sessionState.waitingForAnswer = false;
            sessionState.microphoneReady = false;
            
            if (speechRecognition) {
                speechRecognition.stop();
            }
            if (speechSynthesis) {
                speechSynthesis.cancel();
            }
            
            document.getElementById('startBtn').disabled = false;
            document.getElementById('stopBtn').disabled = true;
            document.getElementById('repeatBtn').disabled = true;
            document.getElementById('skipBtn').disabled = true;
            setManualAnswerEnabled(false);
            
            updateStatus('×”×©×™×¢×•×¨ × ×¢×¦×¨', 'waiting');
            saveSession();
        }

        // Reset session
        function resetSession() {
            stopSession();
            sessionState = {
                currentLabel: 1,
                currentQuestionIndex: 0,
                errors: [],
                isActive: false,
                isListening: false,
                isSpeaking: false,
                currentQuestion: null,
                sessionHistory: [],
                processingAnswer: false,
                waitingForAnswer: false,
                microphoneReady: false,
                isPrimingRecognition: false,
                skipRecognitionResults: false,
                androidPrimed: false,
                voiceInputSupported: !!SpeechRecognitionConstructor,
                voiceOutputSupported: speechSynthesisSupported
            };
            
            document.getElementById('questionDisplay').textContent = '×œ×—×¦×• ×¢×œ "×”×ª×—×œ" ×›×“×™ ×œ×”×ª×—×™×œ ×‘×©×™×¢×•×¨';
            document.getElementById('progressBar').style.width = '0%';
            document.getElementById('historyList').innerHTML = '';
            setManualAnswerEnabled(false);
            
            updateStatus('××•×›×Ÿ ×œ×”×ª×—×œ×ª ×”×©×™×¢×•×¨', 'waiting');
            
            // Clear saved session
            localStorage.removeItem('voiceMathTutorSession');
        }

        // Save session to localStorage
        function saveSession() {
            const sessionData = {
                currentLabel: sessionState.currentLabel,
                currentQuestionIndex: sessionState.currentQuestionIndex,
                errors: sessionState.errors,
                sessionHistory: sessionState.sessionHistory,
                timestamp: new Date().toISOString()
            };
            localStorage.setItem('voiceMathTutorSession', JSON.stringify(sessionData));
        }

        // Load session from localStorage
        function loadSession() {
            const savedSession = localStorage.getItem('voiceMathTutorSession');
            if (savedSession) {
                try {
                    const sessionData = JSON.parse(savedSession);
                    const savedDate = new Date(sessionData.timestamp);
                    const now = new Date();
                    
                    // Only load if saved within last 24 hours
                    if (now - savedDate < 24 * 60 * 60 * 1000) {
                        sessionState.currentLabel = sessionData.currentLabel || 1;
                        sessionState.currentQuestionIndex = sessionData.currentQuestionIndex || 0;
                        sessionState.errors = sessionData.errors || [];
                        sessionState.sessionHistory = sessionData.sessionHistory || [];
                        sessionState.processingAnswer = false;
                        sessionState.waitingForAnswer = false;
                        sessionState.microphoneReady = false;
                        sessionState.isPrimingRecognition = false;
                        sessionState.skipRecognitionResults = false;
                        sessionState.androidPrimed = false;
                        sessionState.voiceInputSupported = !!SpeechRecognitionConstructor;
                        sessionState.voiceOutputSupported = speechSynthesisSupported;
                        
                        // Restore history display
                        const historyList = document.getElementById('historyList');
                        historyList.innerHTML = '';
                        sessionState.sessionHistory.forEach(item => {
                            const historyItem = document.createElement('div');
                            historyItem.className = `history-item ${item.isCorrect ? 'correct' : 'incorrect'}`;
                            const status = item.isCorrect ? 'âœ“' : 'âœ—';
                            historyItem.innerHTML = `
                                <strong>${item.question}</strong><br>
                                ×”×ª×©×•×‘×” ×©×œ×š: ${item.userAnswer} | ×”×ª×©×•×‘×” ×”× ×›×•× ×”: ${item.correctAnswer} ${status}
                            `;
                            historyList.appendChild(historyItem);
                        });
                        
                        updateProgress();
                        showSuccess('×”×©×™×¢×•×¨ ×©×•×—×–×¨. ×××©×™×›×™× ××”××§×•× ×©×¢×¦×¨×ª×.');
                    }
                } catch (error) {
                    console.error('Error loading session:', error);
                }
            }
        }

        // Settings event listeners
        document.getElementById('speechRate').addEventListener('input', function() {
            document.getElementById('rateValue').textContent = this.value;
        });

        document.getElementById('speechPitch').addEventListener('input', function() {
            document.getElementById('pitchValue').textContent = this.value;
        });

        // Initialize on page load
        document.addEventListener('DOMContentLoaded', function() {
            updateStatus('××•×›×Ÿ ×œ×”×ª×—×œ×ª ×”×©×™×¢×•×¨', 'waiting');
            
            if (!window.isSecureContext) {
                console.warn('Microphone permissions require a secure context (https or localhost).');
                showError('×›×“×™ ×œ××¤×©×¨ ×’×™×©×” ×œ××™×§×¨×•×¤×•×Ÿ, ×¤×ª×—×• ××ª ×”×“×£ ×“×¨×š https:// ××• ×‘×××¦×¢×•×ª ×©×¨×ª ××§×•××™ (×œ×“×•×’××” localhost).');
                addCompatibilityNote('×¤×ª×™×—×ª ×”×“×£ ×‘×××¦×¢×•×ª https:// ××• localhost ×××¤×©×¨×ª ×©×™××•×© ××œ× ×‘××™×§×¨×•×¤×•×Ÿ.');
            }

            if (!sessionState.voiceInputSupported) {
                addCompatibilityNote('×”×“×¤×“×¤×Ÿ ×œ× ×ª×•××š ×‘×–×™×”×•×™ ×“×™×‘×•×¨. × ×™×ª×Ÿ ×œ×”×§×œ×™×“ ×ª×©×•×‘×” ×‘×›×œ ×©×œ×‘.');
            }

            if (!sessionState.voiceOutputSupported) {
                addCompatibilityNote('×”×“×¤×“×¤×Ÿ ×œ× ×ª×•××š ×‘×”×§×¨××ª ×§×•×œ. ×”×ª×¨×’×™×œ×™× ×™×•×¦×’×• ×›×˜×§×¡×˜ ×‘×œ×‘×“.');
            }

            if (isSafari) {
                addCompatibilityNote('×‘×“×¤×“×¤×Ÿ Safari ××™×Ÿ ×ª××™×›×” ×‘×–×™×”×•×™ ×“×™×‘×•×¨. ××•××œ×¥ ×œ×”×©×ª××© ×‘-Chrome ××• Edge, ××• ×œ×¢× ×•×ª ×‘×××¦×¢×•×ª ×”×”×§×œ×“×”.');
            }

            if (isOpera) {
                addCompatibilityNote('×‘×›××” ×’×¨×¡××•×ª ×©×œ Opera ×™×© ××’×‘×œ×•×ª ×‘×–×™×”×•×™ ×“×™×‘×•×¨. ×× ××™×Ÿ ×©××¢ ××”××©×ª××©, ×”×©×ª××©×• ×‘×”×§×œ×“×ª ×ª×©×•×‘×” ××• ×¢×‘×¨×• ×œ-Chrome.');
            }

            if (isIOS) {
                addCompatibilityNote('×‘-iPhone/iPad ×”×ª××™×›×” ×‘×–×™×”×•×™ ×“×™×‘×•×¨ ×‘×“×¤×“×¤×Ÿ ××•×’×‘×œ×ª. ×× ××™×Ÿ ×–×™×”×•×™ ×§×•×œ, ×”×©×ª××©×• ×‘×”×§×œ×“×ª ×ª×©×•×‘×”.');
            }

            setManualAnswerEnabled(false);

            if (manualAnswerInput) {
                manualAnswerInput.addEventListener('keydown', function(event) {
                    if (event.key === 'Enter') {
                        event.preventDefault();
                        submitManualAnswer();
                    }
                });
            }
        });
    </script>
</body>
</html>
